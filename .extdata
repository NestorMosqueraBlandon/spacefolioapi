
        // const requestOptionsToken = {
        //   method: 'GET',
        //   uri: `https://api.etherscan.io/api?module=account&action=txlist&address=${portfolio.wallets[1].address}&startblock=0&endblock=9999999&page=1&offset=10&sort=asc&apikey=PM9FSGD1K2AIR9ZMPUKJWVPED5EV1P9QY3`,
        //   qs: {
        //     'start': '1',
        //     'limit': '5000',

        //   },
        //   // headers: {
        //   //   'X-CMC_PRO_API_KEY': '91f97ef8-bc4e-40f9-9d20-7e7e67af1776'
        //   // },
        //   json: true,
        //   gzip: true
        // };

 
        // const url = "https://graphql.bitquery.io/";
        // const opts = {
        //   method: "POST",
        //   headers: {
        //     "Content-Type": "application/json",
        //     "X-API-KEY": "BQYmmb3rW726zLmxE3Fd5aMSyr7AtWT5"
        //   },
        //   body: JSON.stringify({
        //     query
        //   })
        // };
        // fetch(url, opts)
        //   .then(res => res.json())
        //   .then(console.log)
        //   .catch(console.error);



      //   async createWallet(
      //     _,
      //     { name, image, network },
      // ) {
      //     try {
      //         const newWallet = new Exchange({
      //             name,
      //             network,
      //             image,
      //         });
    
      //         await newWallet.save();
    
      //         return 200;
      //     } catch (err) {
      //         return err;
      //     }
      // },


        // createWallet(name: String, image: String, network:String): String







        wallets.map((wallet) => {

                metadata = {
                  balance: wallet.totalQuantity,
                  cryptos: []
                }
    
                walletCryptos = [...wallet.totalTokens.map((token) => {
                  // console.log(token.currency)
                  for (let i = 0; i < data.length; i++) {
                    if (token.currency.symbol) {
                      if (token.currency.symbol.toString().toLowerCase() == data[i].symbol) {
                        // console.log(data[i].name)
                        token.image = data[i].image
                        // console.log(convertValue(Number(token.value),s token.currency.symbol))
                        // token.quantity = token.currency.valueMarket != null && token.value != null? Number(token.value) / Number(token.currency.valueMarket) : 0
    
                        // convertValue(Number(data[i].current_price), token.currency.symbol)
                        token.currency.valueMarket = data[i].current_price != null && token.currency.symbol != null ? data[i].current_price : 0
                        if (token.currency.valueMarket) {
                          // console.log(convertValue(token.value, token.currency.symbol));
                          token.value = convertValue(Number(token.quantity), token.currency.symbol)
                          token.quantity = quantityMarket(token.value, token.currency.valueMarket)
    
                          // coinMarket(token.currency.symbol)
                          // token.value1y = coinMarket(token.currency.symbol)[0]? coinMarket(token.currency.symbol)[0] : 1 ;  
    
    
                          // const cm = coinMarket("bitcoin");
    
                          // const convalue = cm.then(function (result) {
                          //   return result
                          // })
    
                          // console.log("Conva", convalue)
                          // token.value1y = Number(token.currency.valueMarket) / convalue;
                        }
    
                      }
                    }
                  }
                  return token
                })]
              })



    //           async addCoinBlacklist(_, {portfolioId, coinBlacklist}){
    //             try {
    //               const portfolio = await Portfolio.findById(portfolioId);
    //               if (portfolio) {
    //                 await portfolio.coinBlacklist.unshift({
    //                   coinBlacklist,
    //                 });
    //                 await portfolio.save();
    //                 return 200;
    //               } else {
    //                 throw new Error(701);
    //               }
    //             } catch (err) {
    //               throw new Error(701);
    //             }
    //           },


              

    // addCoinBlackList(portfolioId: ID!, coinBlacklist: String): String



  //   try {

  //     const wallets = [];
  //     let metadata = {}
  //     let market = []

  //     const globalData = await CoinGeckoClient.global();

  //     for (let i = 1; i <= Math.round(globalData.data.data.active_cryptocurrencies / 250); i++) {
  //       const { data } = await CoinGeckoClient.coins.markets({ page: i, per_page: 250 });
  //       market = [...market, ...data]
  //     }

  //     let walletCryptos = []
  //     let exchangeCryptos = []


  //     portfolio.wallets.forEach(function (wallet) {
  //       if (!wallets[wallet.network]) {
  //         wallets[wallet.network] = {
  //           network: wallet.network,
  //           totalQuantity: 0,
  //           totalTokens: wallet.tokens
  //         }
  //         wallets.push(wallets[wallet.network]);
  //       };

  //       const tokens = wallet.tokens.reduce((a, d) => (a[d] ? a[d].value += d.value : a[d] = d, a), {})

  //       wallets[wallet.network].totalQuantity = parseFloat(wallet.quantity) + parseFloat(wallets[wallet.network].totalQuantity);
  //       wallets[wallet.network].totalTokens.push(wallet.tokens);

  //       wallets[wallet.network].tokens = tokens;
  //     });

  //     await wallets.map(async (wallet) => {

  //       metadata = {
  //         balance: wallet.totalQuantity,
  //         cryptos: []
  //       }


  //       walletCryptos = await [...wallet.totalTokens.map(async (token) => {
  //         for (let i = 0; i < market.length; i++) {
  //           if (token.currency.symbol) {

  //             if (market[i].symbol == token.currency.symbol.toString().toLowerCase()) {
  //               token.image = await market[i].image
  //               token.currency.valueMarket = await market[i].current_price != null && token.currency.symbol != null ? market[i].current_price.toFixed(9) : 0
  //               if (token.currency.valueMarket) {
  //                 token.quantity = token.value;

  //                 // token.value = await convertValue(Number(token.quantity).toFixed(6), token.currency.symbol)
  //                 if (!token.currency.quantity) {
  //                   // token.quantity = quantityMarket(token.value, token.currency.valueMarket)
  //                 }
  //               }
  //             }
  //           }
  //         }
  //         return token
  //       })]
  //     })

  //     let exchanges = [];

  //     portfolio.exchanges.forEach(function (exchange) {
  //       if (!exchanges[exchange.network]) {
  //         exchanges[exchange.network] = {
  //           network: exchange.network,
  //           totalQuantity: 0,
  //           totalTokens: exchange.tokens
  //         }
  //         exchanges.push(exchanges[exchange.network]);

  //       };

  //       let tokens = [];
  //       tokens = [...tokens, exchange.tokens.reduce((a, d) => (a[d] ? a[d].value += d.value : a[d] = d, a), {})]

  //       exchanges[exchange.network].totalQuantity = parseFloat(exchange.quantity) + parseFloat(exchanges[exchange.network].totalQuantity);
  //       exchanges[exchange.network].totalTokens.push(exchange.tokens);

  //       exchanges[exchange.network].tokens = tokens;
  //     });


  //     metadata.cryptos = [...exchangeCryptos, ...walletCryptos]

  //     return metadata;
  //   }
  //   catch (err) {
  //     console.log(err)
  //   }
  // } else {
  //   return {}
  // }


  // for (let i = 1; i <= Math.round(coinList.data.length / 250); i++) {
  //   const { data } = await CoinGeckoClient.coins.markets({ page: i, per_page: 249 });

  //   walletCoins.map((walletCoin) => {
  //     walletCoinMarket.push(...data.filter((coin) => coin.symbol.toLowerCase() === walletCoin.symbol.toLowerCase()))
  //   })
    
  //   if(walletCoinMarket.length == walletCoins.length){
  //     break;
  //   }
  //   market = [...market, ...data]
  // }




        // for (let i = 0; i < portfolioTokens.length; i++) {
        //   console.log(metadata.cryptos.filter((crypto) => crypto.symbol == portfolioTokens[i].symbol))
        //   if (metadata.cryptos.filter((crypto) => crypto.symbol == portfolioTokens[i].symbol)) {
        //     for (let i = 0; i < metadata.cryptos.length; i++) {
        //       if (metadata.cryptos[i].symbol == portfolioTokens[i].symbol) {
        //         metadata.cryptos[i].usd += portfolioTokens[i].usd
        //       }
        //     }
        //   }
        //   else {
        //     metadata.cryptos.push(portfolioTokens[i])
        //   }
        // }

        // console.log(portfolioTokens)





    async getPortfolios(_, { getInternalData }, context) {
      const user = checkAuth(context);
      const userData = await User.findById(user._id)
      const portfolios = userData.portfolios;
      try 
      {
        if (!portfolios) 
        {
          throw new Error(701)
        }

        let arrayPortfolios = [];
        let firtsArray = [];
        let totalBalance = 0;
        let totalPercentage = 0;
        let totalValue = 0;

        for (let i = 0; i < portfolios.length; i++) 
        {
          let metadata = {}
          let walletCoins = []
          let walletCoinMarket = []
          let portfolioTokens = []

          let exchanges = []
          let wallets = {
            tokens: []
          }

          if (!portfolios) {
            throw new Error(701)
          }

          const coinList = await CoinGeckoClient.coins.list();
          let query;

          if (portfolios[i].wallets.length > 0 && getInternalData === false)  
          {
            for (let j = 0; j < portfolios[i].wallets.length; j++) 
            {
              if (portfolios[i].wallets[j].network == "cardano") 
              {
                 query = `
                 query {
                  cardano{
                    address(address: {in: 
                      "${portfolios[i].wallets[j].address}",
                      }){
                      balance {
                        currency {
                          name
                          symbol
                          tokenId
                        }
                        value
                      }
                      
                    }
                  }
                }
                
              `
              }
              else 
              {
                query = `
                query ($network: EthereumNetwork!, $address: String!) {
                  ethereum(network: $network) {
                    address(address: {is: $address}) {
                      balances {
                        currency {
                          address
                            symbol
                            tokenType
                            name
                        }
                        value
                      }
                      balance
                    }
                  }
                }
     
                `;
              }
              const variables = `
                      {
                      "network": "${portfolios[i].wallets[j].network}",
                      "address": "${portfolios[i].wallets[j].address}"
                      }
                    `;

              const requestOptions = {
                method: 'POST',
                uri: `https://graphql.bitquery.io`,
                headers: {
                  "Content-Type": "application/json",
                  'X-API-KEY': 'BQYmmb3rW726zLmxE3Fd5aMSyr7AtWT5'
                },
                body: ({
                  query,
                  variables
                }),
                json: true,
                gzip: true
              };

              const { data } = await rp(requestOptions);
              if (portfolios[i].wallets[j].network == "cardano") {

                if (data && data.cardano.address[0].balance) {
                  wallets.tokens.push(...data.cardano.address[0].balance.filter((bal) => bal.value > 0))
                }
              } else {
                if (data && data.ethereum.address[0].balances) {
                  wallets.tokens.push(...data.ethereum.address[0].balances.filter((bal) => bal.value > 0))
                }
              }
            }

            // 0x9dF2fe92B91105adE1266f57de548346E9b4009a


            wallets.tokens.forEach((token) => {
              walletCoins.push(...coinList.data.filter((coin) => token.currency.symbol.toLowerCase() == coin.symbol.toLowerCase()))
            })


            for (let i = 0; i < walletCoins.length; i++) {
              const { data } = await CoinGeckoClient.coins.fetch(walletCoins[i].id)
              const { id: coinId, symbol, name, image: { large }, platforms, contract_address, market_data: { current_price: { usd } }, market_data: { price_change_percentage_24h, price_change_percentage_7d, price_change_percentage_30d, price_change_percentage_1y } } = data

              walletCoinMarket.push({ coinId, symbol, name, large, platforms, contract_address, usd, price_change_percentage_24h, price_change_percentage_7d, price_change_percentage_30d, price_change_percentage_1y })
            }


            wallets.tokens.forEach((token) => {
              let arrayResult = Object.assign({ quantity: token.currency.quantity ? token.currency.quantity : token.value }, ...walletCoinMarket.filter((coin) => (token.currency.tokenType == '' || token.currency.contract_address == undefined) && token.currency.symbol.toLowerCase() == coin.symbol ? coin : from(Object.values(coin.platforms)).where(platform => platform == token.currency.address).firstOrDefault()))
              // console.log("arrayresult", arrayResult)
              portfolioTokens.push(arrayResult)
              // newCoinsWallet = walletCoinMarket.filter((coin) => coin.symbol.toLowerCase() == token.currency.symbol.toLowerCase())
            })

            console.log(portfolioTokens)

            // coin.contract_address == undefined || token.currency.symbol.toLowerCase() === coin.contract_address.toLowerCase()? coin :
            // console.log(portfolioTokens)
          }

          if (portfolios[i].exchanges.length > 0 && getInternalData === false) {


            let exchangeCoins = []
            let exchangeCoinMarket = []

            if (portfolios[i].exchanges.length > 0) {

              for (let j = 0; j < portfolios[i].wallets.length; j++) {
                if (portfolios[i].exchanges[j].network === "binance") {

                  const client = new MainClient({
                    api_key: portfolios[i].exchanges[j].apiKey,
                    api_secret: portfolios[i].exchanges[j].apiSecret,
                  });

                  const data = await client.getBalances();

                  const tokens = data.filter((token) => token.free > 0)

                  let exchangePortfolioTokens = [];
                  let newToken = {}

                  tokens.map((token) => {
                    newToken = {}
                    newToken.value = Number(token.free)
                    newToken.currency = {
                      symbol: token.coin,
                      name: token.name
                    }
                    exchangePortfolioTokens.unshift(newToken)
                  })


                  let exchangeCoins = []
                  let exchangeCoinMarket = []


                  exchangePortfolioTokens.forEach((token) => {
                    exchangeCoins.push(...coinList.data.filter((coin) => token.currency.symbol.toLowerCase() == coin.symbol.toLowerCase()))
                  })

                  for (let i = 0; i < exchangeCoins.length; i++) {
                    const { data } = await CoinGeckoClient.coins.fetch(exchangeCoins[i].id)
                    const { symbol, name, image: { large }, contract_address, market_data: { current_price: { usd } }, coingecko_rank, market_data: { price_change_percentage_24h, price_change_percentage_7d, price_change_percentage_30d, price_change_percentage_1y } } = data
                    exchangeCoinMarket.push({ symbol, name, large, contract_address, usd, coingecko_rank, price_change_percentage_24h, price_change_percentage_7d, price_change_percentage_30d, price_change_percentage_1y })
                  }

                  let newCoins;
                  let newExchangesTokens = [];

                  exchangePortfolioTokens.forEach((token) => {
                    let arrayResult = Object.assign({ quantity: token.currency.quantity ? token.currency.quantity : token.value }, ...exchangeCoinMarket.filter((coin) => token.currency.symbol.toLowerCase() == coin.symbol))
                    newExchangesTokens.push(arrayResult)
                    // newCoins = exchangeCoinMarket.filter((coin) => coin.symbol.toLowerCase() == token.currency.symbol.toLowerCase())


                    newExchangesTokens.sort((a, c) => a.coingecko_rank - c.coingecko_rank)

                    portfolioTokens.push(arrayResult)
                  })



                  portfolioTokens.push(exchangePortfolioTokens)

                }

                if (portfolios[i].exchanges[j].network === "coinbase") {
                  const myClient = new Client({
                    'apiKey': portfolio.exchanges[j].apiKey,
                    'apiSecret': portfolio.exchanges[j].apiSecret,
                    strictSSL: false
                  });

                  let portfolioTokens = [];
                  let newToken = {}

                  myClient.getAccounts({}, async (err, accounts) => {
                    accounts.forEach(async (acct) => {
                      if (acct.balances.amount > 0) {
                        newToken = {}
                        newToken.value = Number(acct.native_balance.amount)
                        newToken.currency = {
                          symbol: acct.currency,
                          name: acct.name,
                          quantity: Number(acct.balance.amount)
                        }
                        portfolioTokens.unshift(newToken)
                      }
                    })
                  })

                  let exchangeCoins = []
                  let exchangeCoinMarket = []


                  portfolioTokens.forEach((token) => {
                    exchangeCoins.push(...coinList.data.filter((coin) => token.currency.symbol.toLowerCase() == coin.symbol.toLowerCase()))
                  })

                  for (let i = 0; i < exchangeCoins.length; i++) {
                    const { data } = await CoinGeckoClient.coins.fetch(exchangeCoins[i].id)
                    const { symbol, name, image: { large }, contract_address, market_data: { current_price: { usd } }, coingecko_rank, market_data: { price_change_percentage_24h, price_change_percentage_7d, price_change_percentage_30d, price_change_percentage_1y } } = data
                    exchangeCoinMarket.push({ symbol, name, large, contract_address, usd, coingecko_rank, price_change_percentage_24h, price_change_percentage_7d, price_change_percentage_30d, price_change_percentage_1y })
                  }

                  let newCoins;
                  let newExchangesTokens = [];

                  portfolioTokens.forEach((token) => {
                    let arrayResult = Object.assign({ quantity: token.currency.quantity ? token.currency.quantity : token.value }, ...exchangeCoinMarket.filter((coin) => token.currency.symbol.toLowerCase() == coin.symbol))
                    newExchangesTokens.push(arrayResult)

                    portfolioTokens.push(arrayResult)

                    newExchangesTokens.sort((a, c) => a.coingecko_rank - c.coingecko_rank)
                  })

                }


              }

            }

          }

            if (getInternalData === false) 
            {
                metadata = {
                  balance: 0,
                  percentage: 0,
                  cryptos: [],
                  chart: ''
                }


                metadata.cryptos = from(portfolioTokens).groupBy(tokens => tokens.symbol, null, (key, t) => {
                  return {
                    symbol: key,
                    coinId: t.first().coinId,
                    quantity: t.sum(token => token["quantity"] || 0),
                    name: t.first().name,
                    image: t.first().large,
                    valueMarket: t.first().usd,
                    value: t.sum(token => token["quantity"]) * t.first().usd,

                    value_usd_24h: (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_24h),

                    value_usd_7d: (t.first().price_change_percentage_7d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? token["quantity"] * t.first().usd * t.first().price_change_percentage_24h / 100 : (t.first().price_change_percentage_7d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100,

                    value_usd_30d: (t.first().price_change_percentage_30d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? (t.first().price_change_percentage_7d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_24h) : (t.first().price_change_percentage_7d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 : (t.first().price_change_percentage_30d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100,

                    value_usd_1y: (t.first().price_change_percentage_1y * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? (t.first().price_change_percentage_30d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? (t.first().price_change_percentage_7d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_24h) : (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_7d) : (t.first().price_change_percentage_30d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 : (t.first().price_change_percentage_1y * (t.sum(token => token["quantity"]) * t.first().usd)) / 100,

                    price_change_percentage_24h: (100 / (t.sum(token => token["quantity"]) * t.first().usd)) * (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_24h),

                    price_change_percentage_7d: (100 / (t.sum(token => token["quantity"]) * t.first().usd)) * (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_7d) == 0 ? (100 / (t.sum(token => token["quantity"]) * t.first().usd)) * (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_24h) : (100 / (t.sum(token => token["quantity"]) * t.first().usd)) * (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_7d),

                    price_change_percentage_30d: (t.first().price_change_percentage_30d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? (t.first().price_change_percentage_7d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_24h) : (t.first().price_change_percentage_7d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 : (t.first().price_change_percentage_30d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100,

                    price_change_percentage_1y: (t.first().price_change_percentage_1y * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? (t.first().price_change_percentage_30d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? (t.first().price_change_percentage_7d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_24h) : (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_7d) : (t.first().price_change_percentage_30d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 : (t.first().price_change_percentage_1y * (t.sum(token => token["quantity"]) * t.first().usd)) / 100,
                  };
                }).toArray()


                metadata.cryptos = metadata.cryptos.filter((crypto) => crypto.symbol != undefined)
                metadata.balance = metadata.cryptos.reduce((a, c) => a + c.value * 1, 0)

                let sumPercentage = metadata.cryptos.reduce((a, c) => a + c.price_change_percentage_30d * 1, 0)
                let sumPercentageUsd = metadata.cryptos.reduce((a, c) => a + c.value_usd_7d * 1, 0)

                let avg = sumPercentage / metadata.cryptos.length;
                let avgUsd = sumPercentageUsd / metadata.cryptos.length;

                totalBalance += metadata.balance;
                totalPercentage += avg
                totalValue += avgUsd

                let percentage = (metadata.balance / totalBalance) * 100
                firtsArray.push({ id: portfolios[i].id, name: portfolios[i].name, balance: metadata.balance, price_change_percentage: avg, value_usd: avgUsd })
                // arrayPortfolios.push({ name: portfolios[i].name, balance: metadata.balance })


                for (let k = 0; k < portfolios.length; k++) {
                  let percentage = (firtsArray[k].balance / totalBalance) * 100
                  arrayPortfolios.push({ id: firtsArray[k].id, name: firtsArray[k].name, balance: firtsArray[k].balance, price_change_percentage: firtsArray[k].price_change_percentage, percentage, value_usd: firtsArray[k].value_usd })
                }

                let metadataArray = {
                  totalBalance: 0,
                  totalPercetage: 0,
                  totalValue: 0,
                  portfolios: []
                }

                metadataArray = { totalBalance, totalPercentage, totalValue, portfolios: arrayPortfolios }
          

                return metadataArray;
            } else 
            {
                  let metadataArray = {
                  totalBalance: 0,
                  portfolios: []
                }

                metadataArray = { portfolios }
                return metadataArray
            }
        }

      } catch (err) {
        console.log(err)
        // throw new Error(err);
      }
    },




    // METADATA RELASE CHANGE CODE

    async getMetadataPortfolio(_, { portfolioId, userId, interval = false }, context) {

      const user = checkAuth(context);

      const userData = await User.findById(user._id)

      const portfolioIde = userData.portfolios.findIndex(port => port.id == portfolioId)

      const portfolio = userData.portfolios[portfolioIde];

      let metadata = {}
      let walletCoins = []
      let walletCoinMarket = []
      let portfolioTokens = []

      let exchanges = []
      let wallets = {
        tokens: []
      }

      if (!portfolio) {
        throw new Error(701)
      }

      const coinList = await CoinGeckoClient.coins.list();

      let query;
      if (portfolio.wallets.length > 0) {
        for (let j = 0; j < portfolio.wallets.length; j++) {

          if (portfolio.wallets[j].network == "cardano") {
            query = `
            query {
              cardano{
                address(address: {in: 
                  "${portfolio.wallets[j].address}",
                  }){
                  balance {
                    currency {
                      name
                      symbol
                      tokenId
                    }
                    value
                  }
                  
                }
              }
            }
            
        `
          }
          else {

            query = `
     query ($network: EthereumNetwork!, $address: String!) {
      ethereum(network: $network) {
         address(address: {is: $address}) {
           balances {
             currency {
               address
               symbol
               tokenType
               name
             }
             value
           }
           balance
         }
       }
     }
     
    `;
          }

          const variables = `
    {
     "network": "${portfolio.wallets[j].network}",
     "address": "${portfolio.wallets[j].address}"
    }
    
    `;

          const requestOptions = {
            method: 'POST',
            uri: `https://graphql.bitquery.io`,
            headers: {
              "Content-Type": "application/json",
              'X-API-KEY': 'BQYmmb3rW726zLmxE3Fd5aMSyr7AtWT5'
            },
            body: ({
              query,
              variables

            }),
            json: true,
            gzip: true
          };

          const { data } = await rp(requestOptions);
          if (portfolio.wallets[j].network == "cardano") {

            if (data && data.cardano.address[0].balance) {
              wallets.tokens.push(...data.cardano.address[0].balance.filter((bal) => bal.value > 0))
            }
          } else {
            if (data && data.ethereum.address[0].balances) {
              wallets.tokens.push(...data.ethereum.address[0].balances.filter((bal) => bal.value > 0))
            }
          }
        }

        wallets.tokens.forEach((token) => {
          walletCoins.push(...coinList.data.filter((coin) => token.currency.symbol.toLowerCase() == coin.symbol.toLowerCase()))
        })


        for (let i = 0; i < walletCoins.length; i++) {
          const { data } = await CoinGeckoClient.coins.fetch(walletCoins[i].id)
          const { id: coinId, symbol, name, image: { large }, platforms, contract_address, market_data: { current_price: { usd } }, market_data: { price_change_percentage_24h, price_change_percentage_7d, price_change_percentage_30d, price_change_percentage_1y } } = data

          walletCoinMarket.push({ coinId, symbol, name, large, platforms, contract_address, usd, price_change_percentage_24h, price_change_percentage_7d, price_change_percentage_30d, price_change_percentage_1y })
        }

        wallets.tokens.forEach((token) => {
          let arrayResult = Object.assign({ quantity: token.currency.quantity ? token.currency.quantity : token.value }, ...walletCoinMarket.filter((coin) => (token.currency.tokenType == '' || !token.currency.tokenType && token.currency.tokenId == null) && token.currency.symbol.toLowerCase() == coin.symbol ? coin : from(Object.values(coin.platforms)).where(platform => platform == token.currency.address).firstOrDefault()))
          portfolioTokens.push(arrayResult)
        })
      }

      if (portfolio.exchanges.length > 0) {
          for (let j = 0; j < portfolio.exchanges.length; j++) {
            if (portfolio.exchanges[j].network === "binance") {
              const client = new MainClient({
                api_key: portfolio.exchanges[j].apiKey,
                api_secret: portfolio.exchanges[j].apiSecret,
              });

              const data = await client.getBalances();

              const tokens = data.filter((token) => token.free > 0)

              let exchangePortfolioTokens = [];
              let newToken = {}

              tokens.map((token) => {
                newToken = {}
                newToken.value = Number(token.free)
                newToken.currency = {
                  symbol: token.coin,
                  name: token.name
                }
                exchangePortfolioTokens.unshift(newToken)
              })


              let exchangeCoins = []
              let exchangeCoinMarket = []


              exchangePortfolioTokens.forEach((token) => {
                exchangeCoins.push(...coinList.data.filter((coin) => token.currency.symbol.toLowerCase() == coin.symbol.toLowerCase()))
              })

              for (let i = 0; i < exchangeCoins.length; i++) {
                const { data } = await CoinGeckoClient.coins.fetch(exchangeCoins[i].id)
                const { symbol, name, image: { large }, contract_address, market_data: { current_price: { usd } }, coingecko_rank, market_data: { price_change_percentage_24h, price_change_percentage_7d, price_change_percentage_30d, price_change_percentage_1y } } = data
                exchangeCoinMarket.push({ symbol, name, large, contract_address, usd, coingecko_rank, price_change_percentage_24h, price_change_percentage_7d, price_change_percentage_30d, price_change_percentage_1y })
              }

              let newCoins;
              let newExchangesTokens = [];

              exchangePortfolioTokens.forEach((token) => {
                let arrayResult = Object.assign({ quantity: token.currency.quantity ? token.currency.quantity : token.value }, ...exchangeCoinMarket.filter((coin) => token.currency.symbol.toLowerCase() == coin.symbol))
                newExchangesTokens.push(arrayResult)
                newExchangesTokens.sort((a, c) => a.coingecko_rank - c.coingecko_rank)

                portfolioTokens.push(arrayResult)
              })



              portfolioTokens.push(exchangePortfolioTokens)
            }

            if (portfolio.exchanges[j].network === "coinbase") {
              const myClient = new Client({
                'apiKey': portfolio.exchanges[j].apiKey,
                'apiSecret': portfolio.exchanges[j].apiSecret,
                strictSSL: false
              });

              let portfolioTokens = [];
              let newToken = {}

              myClient.getAccounts({}, (err, accounts) => {
                console.log(accounts)
              })

              myClient.getAccounts({}, async (err, accounts) => {
                accounts.forEach(async (acct) => {
                  if (acct.balances.amount > 0) {
                    newToken = {}
                    newToken.value = Number(acct.native_balance.amount)
                    newToken.currency = {
                      symbol: acct.currency,
                      name: acct.name,
                      quantity: Number(acct.balance.amount)
                    }
                    portfolioTokens.unshift(newToken)
                  }
                })
              })

              let exchangeCoins = []
              let exchangeCoinMarket = []


              portfolioTokens.forEach((token) => {
                exchangeCoins.push(...coinList.data.filter((coin) => token.currency.symbol.toLowerCase() == coin.symbol.toLowerCase()))
              })

              for (let i = 0; i < exchangeCoins.length; i++) {
                const { data } = await CoinGeckoClient.coins.fetch(exchangeCoins[i].id)
                const { symbol, name, image: { large }, contract_address, market_data: { current_price: { usd } }, coingecko_rank, market_data: { price_change_percentage_24h, price_change_percentage_7d, price_change_percentage_30d, price_change_percentage_1y } } = data
                exchangeCoinMarket.push({ symbol, name, large, contract_address, usd, coingecko_rank, price_change_percentage_24h, price_change_percentage_7d, price_change_percentage_30d, price_change_percentage_1y })
              }

              let newCoins;
              let newExchangesTokens = [];

              portfolioTokens.forEach((token) => {
                let arrayResult = Object.assign({ quantity: token.currency.quantity ? token.currency.quantity : token.value }, ...exchangeCoinMarket.filter((coin) => token.currency.symbol.toLowerCase() == coin.symbol))
                newExchangesTokens.push(arrayResult)

                portfolioTokens.push(arrayResult)

                newExchangesTokens.sort((a, c) => a.coingecko_rank - c.coingecko_rank)
              })

            }


          }
        
      }

      metadata = {
        balance: 0,
        price_change_percentage_24h: 0,
        price_change_percentage_7d: 0,
        price_change_percentage_30d: 0,
        price_change_percentage_1y: 0,
        value_24h: 0,
        value_7d: 0,
        value_30d: 0,
        value_1y: 0,
        cryptos: [],
        chart: ''
      }


      metadata.cryptos = from(portfolioTokens).groupBy(tokens => tokens.symbol, null, (key, t) => {
        return {
          symbol: key,
          coinId: t.first().coinId,
          quantity: t.sum(token => token["quantity"] || 0),
          name: t.first().name,
          image: t.first().large,
          valueMarket: t.first().usd,
          value: t.sum(token => token["quantity"]) * t.first().usd,

          value_usd_24h: (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_24h),

          value_usd_7d: (t.first().price_change_percentage_7d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? token["quantity"] * t.first().usd * t.first().price_change_percentage_24h / 100 : (t.first().price_change_percentage_7d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100,

          value_usd_30d: (t.first().price_change_percentage_30d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? (t.first().price_change_percentage_7d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_24h) : (t.first().price_change_percentage_7d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 : (t.first().price_change_percentage_30d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100,

          value_usd_1y: (t.first().price_change_percentage_1y * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? (t.first().price_change_percentage_30d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? (t.first().price_change_percentage_7d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_24h) : (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_7d) : (t.first().price_change_percentage_30d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 : (t.first().price_change_percentage_1y * (t.sum(token => token["quantity"]) * t.first().usd)) / 100,

          price_change_percentage_24h: (100 / (t.sum(token => token["quantity"]) * t.first().usd)) * (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_24h),

          price_change_percentage_7d: (100 / (t.sum(token => token["quantity"]) * t.first().usd)) * (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_7d) == 0 ? (100 / (t.sum(token => token["quantity"]) * t.first().usd)) * (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_24h) : (100 / (t.sum(token => token["quantity"]) * t.first().usd)) * (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_7d),

          price_change_percentage_30d: (t.first().price_change_percentage_30d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? (t.first().price_change_percentage_7d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_24h) : (t.first().price_change_percentage_7d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 : (t.first().price_change_percentage_30d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100,

          price_change_percentage_1y: (t.first().price_change_percentage_1y * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? (t.first().price_change_percentage_30d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? (t.first().price_change_percentage_7d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 == 0 ? (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_24h) : (((t.sum(token => token["quantity"]) * t.first().usd) / 100) * t.first().price_change_percentage_7d) : (t.first().price_change_percentage_30d * (t.sum(token => token["quantity"]) * t.first().usd)) / 100 : (t.first().price_change_percentage_1y * (t.sum(token => token["quantity"]) * t.first().usd)) / 100,
        };
      }).toArray()

      // console.log(metadata)

      metadata.cryptos = metadata.cryptos.filter((crypto) => crypto.symbol != undefined)
      metadata.balance = metadata.cryptos.reduce((a, c) => a + c.value * 1, 0)
      metadata.price_change_percentage_24h = metadata.cryptos.reduce((a, c) => a + c.price_change_percentage_24h * 1, 0)
      metadata.price_change_percentage_7d = metadata.cryptos.reduce((a, c) => a + c.price_change_percentage_7d * 1, 0)
      metadata.price_change_percentage_30d = metadata.cryptos.reduce((a, c) => a + c.price_change_percentage_30d * 1, 0)
      metadata.price_change_percentage_1y = metadata.cryptos.reduce((a, c) => a + c.price_change_percentage_1y * 1, 0)
      metadata.value_24h = metadata.cryptos.reduce((a, c) => a + c.value_usd_24h * 1, 0)
      metadata.value_7d = metadata.cryptos.reduce((a, c) => a + c.value_usd_7d * 1, 0)
      metadata.value_30d = metadata.cryptos.reduce((a, c) => a + c.value_usd_30d * 1, 0)
      metadata.value_1y = metadata.cryptos.reduce((a, c) => a + c.value_usd_1y * 1, 0)




      let chart = ""
      if (interval) {
        chart = JSON.stringify(await portfolioChart(metadata.balance, JSON.parse(userData.portfolioGeneralChart)))
        userData.portfolios[portfolioIde].portfolioGeneralChart = chart;
        await userData.save();
        metadata.chart = chart;
      }


      return metadata

    },
  },


  // CONVERT VALUE

  const convertValue = async (amount, symbol) => {

    const requestOptions = {
      method: 'GET',
      uri: 'https://pro-api.coinmarketcap.com/v1/tools/price-conversion',
      qs: {
        "amount": amount,
        "symbol": symbol,
        "convert": "USD"
      },
      headers: {
        'X-CMC_PRO_API_KEY': '91f97ef8-bc4e-40f9-9d20-7e7e67af1776'
      },
      json: true,
      gzip: true
    };
  
    try {
      const { data } = await rp(requestOptions);
      return data.quote["USD"].price
    }
    catch (err) {
      console.log(err)
    }
  }

  // QUANTITY MARKET 

  const quantityMarket = async (value, valueMarket) => {

    const quantity = await valueMarket != null && value != null ? Number(value) / Number(valueMarket) : 0
  
    return quantity;
  
  }





















  walletTestDatabase.map((data) => {
    portfolioTokens.push({
      coinId: data.coinId,
      symbol: data.symbol,
      name: data.name,
      large: 'https://assets.coingecko.com/coins/images/4128/large/Solana.jpg?1635329178',
      platforms: { '': '' },
      contract_address: undefined,
      usd: 191.7,
      price_change_percentage_24h: -17.26285,
      price_change_percentage_7d: -0.23047,
      price_change_percentage_30d: -20.79833,
      price_change_percentage_1y: 9042.93334
    })
  })
  // console.log(portfolioTokens)


          // if (userData.portfolios[portfolioIde].wallets[wallet].id === walletId) {
                //     userData.portfolios[portfolioIde].wallets[wallet] = ({
                //         name: name ? name : portfolio.wallets[wallet].name,
                //         // address: publicAddress ? publicAddress : portfolio.wallets[wallet].address,
                //         active: active ? active : portfolio.wallets[wallet].active,
                //         network: portfolio.wallets[wallet].network,
                //         image: portfolio.wallets[wallet].image,
                //         tokens: walletTestDatabase
                //     })
                // }


                                // walletTestDatabase.map((walletDbValue) => {
                    //   console.log(walletDbValue)
                    //     try {
                    //         from(walletTestBitquery).where((walletApiValue) => walletDbValue.currency.symbol == walletApiValue.symbol).first()
                    //     } catch (err) {
                    //         walletTestDatabase.pop(walletDbValue);
                    //     }
                    // })