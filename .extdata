
        // const requestOptionsToken = {
        //   method: 'GET',
        //   uri: `https://api.etherscan.io/api?module=account&action=txlist&address=${portfolio.wallets[1].address}&startblock=0&endblock=9999999&page=1&offset=10&sort=asc&apikey=PM9FSGD1K2AIR9ZMPUKJWVPED5EV1P9QY3`,
        //   qs: {
        //     'start': '1',
        //     'limit': '5000',

        //   },
        //   // headers: {
        //   //   'X-CMC_PRO_API_KEY': '91f97ef8-bc4e-40f9-9d20-7e7e67af1776'
        //   // },
        //   json: true,
        //   gzip: true
        // };

 
        // const url = "https://graphql.bitquery.io/";
        // const opts = {
        //   method: "POST",
        //   headers: {
        //     "Content-Type": "application/json",
        //     "X-API-KEY": "BQYmmb3rW726zLmxE3Fd5aMSyr7AtWT5"
        //   },
        //   body: JSON.stringify({
        //     query
        //   })
        // };
        // fetch(url, opts)
        //   .then(res => res.json())
        //   .then(console.log)
        //   .catch(console.error);



      //   async createWallet(
      //     _,
      //     { name, image, network },
      // ) {
      //     try {
      //         const newWallet = new Exchange({
      //             name,
      //             network,
      //             image,
      //         });
    
      //         await newWallet.save();
    
      //         return 200;
      //     } catch (err) {
      //         return err;
      //     }
      // },


        // createWallet(name: String, image: String, network:String): String







        wallets.map((wallet) => {

                metadata = {
                  balance: wallet.totalQuantity,
                  cryptos: []
                }
    
                walletCryptos = [...wallet.totalTokens.map((token) => {
                  // console.log(token.currency)
                  for (let i = 0; i < data.length; i++) {
                    if (token.currency.symbol) {
                      if (token.currency.symbol.toString().toLowerCase() == data[i].symbol) {
                        // console.log(data[i].name)
                        token.image = data[i].image
                        // console.log(convertValue(Number(token.value),s token.currency.symbol))
                        // token.quantity = token.currency.valueMarket != null && token.value != null? Number(token.value) / Number(token.currency.valueMarket) : 0
    
                        // convertValue(Number(data[i].current_price), token.currency.symbol)
                        token.currency.valueMarket = data[i].current_price != null && token.currency.symbol != null ? data[i].current_price : 0
                        if (token.currency.valueMarket) {
                          // console.log(convertValue(token.value, token.currency.symbol));
                          token.value = convertValue(Number(token.quantity), token.currency.symbol)
                          token.quantity = quantityMarket(token.value, token.currency.valueMarket)
    
                          // coinMarket(token.currency.symbol)
                          // token.value1y = coinMarket(token.currency.symbol)[0]? coinMarket(token.currency.symbol)[0] : 1 ;  
    
    
                          // const cm = coinMarket("bitcoin");
    
                          // const convalue = cm.then(function (result) {
                          //   return result
                          // })
    
                          // console.log("Conva", convalue)
                          // token.value1y = Number(token.currency.valueMarket) / convalue;
                        }
    
                      }
                    }
                  }
                  return token
                })]
              })



    //           async addCoinBlacklist(_, {portfolioId, coinBlacklist}){
    //             try {
    //               const portfolio = await Portfolio.findById(portfolioId);
    //               if (portfolio) {
    //                 await portfolio.coinBlacklist.unshift({
    //                   coinBlacklist,
    //                 });
    //                 await portfolio.save();
    //                 return 200;
    //               } else {
    //                 throw new Error(701);
    //               }
    //             } catch (err) {
    //               throw new Error(701);
    //             }
    //           },


              

    // addCoinBlackList(portfolioId: ID!, coinBlacklist: String): String



  //   try {

  //     const wallets = [];
  //     let metadata = {}
  //     let market = []

  //     const globalData = await CoinGeckoClient.global();

  //     for (let i = 1; i <= Math.round(globalData.data.data.active_cryptocurrencies / 250); i++) {
  //       const { data } = await CoinGeckoClient.coins.markets({ page: i, per_page: 250 });
  //       market = [...market, ...data]
  //     }

  //     let walletCryptos = []
  //     let exchangeCryptos = []


  //     portfolio.wallets.forEach(function (wallet) {
  //       if (!wallets[wallet.network]) {
  //         wallets[wallet.network] = {
  //           network: wallet.network,
  //           totalQuantity: 0,
  //           totalTokens: wallet.tokens
  //         }
  //         wallets.push(wallets[wallet.network]);
  //       };

  //       const tokens = wallet.tokens.reduce((a, d) => (a[d] ? a[d].value += d.value : a[d] = d, a), {})

  //       wallets[wallet.network].totalQuantity = parseFloat(wallet.quantity) + parseFloat(wallets[wallet.network].totalQuantity);
  //       wallets[wallet.network].totalTokens.push(wallet.tokens);

  //       wallets[wallet.network].tokens = tokens;
  //     });

  //     await wallets.map(async (wallet) => {

  //       metadata = {
  //         balance: wallet.totalQuantity,
  //         cryptos: []
  //       }


  //       walletCryptos = await [...wallet.totalTokens.map(async (token) => {
  //         for (let i = 0; i < market.length; i++) {
  //           if (token.currency.symbol) {

  //             if (market[i].symbol == token.currency.symbol.toString().toLowerCase()) {
  //               token.image = await market[i].image
  //               token.currency.valueMarket = await market[i].current_price != null && token.currency.symbol != null ? market[i].current_price.toFixed(9) : 0
  //               if (token.currency.valueMarket) {
  //                 token.quantity = token.value;

  //                 // token.value = await convertValue(Number(token.quantity).toFixed(6), token.currency.symbol)
  //                 if (!token.currency.quantity) {
  //                   // token.quantity = quantityMarket(token.value, token.currency.valueMarket)
  //                 }
  //               }
  //             }
  //           }
  //         }
  //         return token
  //       })]
  //     })

  //     let exchanges = [];

  //     portfolio.exchanges.forEach(function (exchange) {
  //       if (!exchanges[exchange.network]) {
  //         exchanges[exchange.network] = {
  //           network: exchange.network,
  //           totalQuantity: 0,
  //           totalTokens: exchange.tokens
  //         }
  //         exchanges.push(exchanges[exchange.network]);

  //       };

  //       let tokens = [];
  //       tokens = [...tokens, exchange.tokens.reduce((a, d) => (a[d] ? a[d].value += d.value : a[d] = d, a), {})]

  //       exchanges[exchange.network].totalQuantity = parseFloat(exchange.quantity) + parseFloat(exchanges[exchange.network].totalQuantity);
  //       exchanges[exchange.network].totalTokens.push(exchange.tokens);

  //       exchanges[exchange.network].tokens = tokens;
  //     });


  //     metadata.cryptos = [...exchangeCryptos, ...walletCryptos]

  //     return metadata;
  //   }
  //   catch (err) {
  //     console.log(err)
  //   }
  // } else {
  //   return {}
  // }


  // for (let i = 1; i <= Math.round(coinList.data.length / 250); i++) {
  //   const { data } = await CoinGeckoClient.coins.markets({ page: i, per_page: 249 });

  //   walletCoins.map((walletCoin) => {
  //     walletCoinMarket.push(...data.filter((coin) => coin.symbol.toLowerCase() === walletCoin.symbol.toLowerCase()))
  //   })
    
  //   if(walletCoinMarket.length == walletCoins.length){
  //     break;
  //   }
  //   market = [...market, ...data]
  // }




        // for (let i = 0; i < portfolioTokens.length; i++) {
        //   console.log(metadata.cryptos.filter((crypto) => crypto.symbol == portfolioTokens[i].symbol))
        //   if (metadata.cryptos.filter((crypto) => crypto.symbol == portfolioTokens[i].symbol)) {
        //     for (let i = 0; i < metadata.cryptos.length; i++) {
        //       if (metadata.cryptos[i].symbol == portfolioTokens[i].symbol) {
        //         metadata.cryptos[i].usd += portfolioTokens[i].usd
        //       }
        //     }
        //   }
        //   else {
        //     metadata.cryptos.push(portfolioTokens[i])
        //   }
        // }

        // console.log(portfolioTokens)